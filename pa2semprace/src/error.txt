==73932== Memcheck, a memory error detector
==73932== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==73932== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info
==73932== Command: ./a.out
==73932== 
==73932== Invalid read of size 8
==73932==    at 0x10C58F: std::unique_ptr<CTower, std::default_delete<CTower> >::~unique_ptr() (unique_ptr.h:291)
==73932==    by 0x10C46A: void std::_Destroy<std::unique_ptr<CTower, std::default_delete<CTower> > >(std::unique_ptr<CTower, std::default_delete<CTower> >*) (stl_construct.h:98)
==73932==    by 0x10C306: void std::_Destroy_aux<false>::__destroy<std::unique_ptr<CTower, std::default_delete<CTower> >*>(std::unique_ptr<CTower, std::default_delete<CTower> >*, std::unique_ptr<CTower, std::default_delete<CTower> >*) (stl_construct.h:108)
==73932==    by 0x10C10F: void std::_Destroy<std::unique_ptr<CTower, std::default_delete<CTower> >*>(std::unique_ptr<CTower, std::default_delete<CTower> >*, std::unique_ptr<CTower, std::default_delete<CTower> >*) (stl_construct.h:137)
==73932==    by 0x10BED2: void std::_Destroy<std::unique_ptr<CTower, std::default_delete<CTower> >*, std::unique_ptr<CTower, std::default_delete<CTower> > >(std::unique_ptr<CTower, std::default_delete<CTower> >*, std::unique_ptr<CTower, std::default_delete<CTower> >*, std::allocator<std::unique_ptr<CTower, std::default_delete<CTower> > >&) (stl_construct.h:206)
==73932==    by 0x10BC68: std::vector<std::unique_ptr<CTower, std::default_delete<CTower> >, std::allocator<std::unique_ptr<CTower, std::default_delete<CTower> > > >::~vector() (stl_vector.h:677)
==73932==    by 0x10FA2B: std::vector<std::unique_ptr<CTower, std::default_delete<CTower> >, std::allocator<std::unique_ptr<CTower, std::default_delete<CTower> > > >::_M_move_assign(std::vector<std::unique_ptr<CTower, std::default_delete<CTower> >, std::allocator<std::unique_ptr<CTower, std::default_delete<CTower> > > >&&, std::integral_constant<bool, true>) (stl_vector.h:1814)
==73932==    by 0x10F454: std::vector<std::unique_ptr<CTower, std::default_delete<CTower> >, std::allocator<std::unique_ptr<CTower, std::default_delete<CTower> > > >::operator=(std::vector<std::unique_ptr<CTower, std::default_delete<CTower> >, std::allocator<std::unique_ptr<CTower, std::default_delete<CTower> > > >&&) (stl_vector.h:711)
==73932==    by 0x10EEC2: CMap::operator=(CMap&&) (CMap.hpp:20)
==73932==    by 0x10DEBE: CGame::CGame(int, int) (CGame.cpp:20)
==73932==  Address 0x0 is not stack'd, malloc'd or (recently) free'd
==73932== 
==73932== 
==73932== Process terminating with default action of signal 11 (SIGSEGV)
==73932==  Access not within mapped region at address 0x0
==73932==    at 0x10C58F: std::unique_ptr<CTower, std::default_delete<CTower> >::~unique_ptr() (unique_ptr.h:291)
==73932==    by 0x10C46A: void std::_Destroy<std::unique_ptr<CTower, std::default_delete<CTower> > >(std::unique_ptr<CTower, std::default_delete<CTower> >*) (stl_construct.h:98)
==73932==    by 0x10C306: void std::_Destroy_aux<false>::__destroy<std::unique_ptr<CTower, std::default_delete<CTower> >*>(std::unique_ptr<CTower, std::default_delete<CTower> >*, std::unique_ptr<CTower, std::default_delete<CTower> >*) (stl_construct.h:108)
==73932==    by 0x10C10F: void std::_Destroy<std::unique_ptr<CTower, std::default_delete<CTower> >*>(std::unique_ptr<CTower, std::default_delete<CTower> >*, std::unique_ptr<CTower, std::default_delete<CTower> >*) (stl_construct.h:137)
==73932==    by 0x10BED2: void std::_Destroy<std::unique_ptr<CTower, std::default_delete<CTower> >*, std::unique_ptr<CTower, std::default_delete<CTower> > >(std::unique_ptr<CTower, std::default_delete<CTower> >*, std::unique_ptr<CTower, std::default_delete<CTower> >*, std::allocator<std::unique_ptr<CTower, std::default_delete<CTower> > >&) (stl_construct.h:206)
==73932==    by 0x10BC68: std::vector<std::unique_ptr<CTower, std::default_delete<CTower> >, std::allocator<std::unique_ptr<CTower, std::default_delete<CTower> > > >::~vector() (stl_vector.h:677)
==73932==    by 0x10FA2B: std::vector<std::unique_ptr<CTower, std::default_delete<CTower> >, std::allocator<std::unique_ptr<CTower, std::default_delete<CTower> > > >::_M_move_assign(std::vector<std::unique_ptr<CTower, std::default_delete<CTower> >, std::allocator<std::unique_ptr<CTower, std::default_delete<CTower> > > >&&, std::integral_constant<bool, true>) (stl_vector.h:1814)
==73932==    by 0x10F454: std::vector<std::unique_ptr<CTower, std::default_delete<CTower> >, std::allocator<std::unique_ptr<CTower, std::default_delete<CTower> > > >::operator=(std::vector<std::unique_ptr<CTower, std::default_delete<CTower> >, std::allocator<std::unique_ptr<CTower, std::default_delete<CTower> > > >&&) (stl_vector.h:711)
==73932==    by 0x10EEC2: CMap::operator=(CMap&&) (CMap.hpp:20)
==73932==    by 0x10DEBE: CGame::CGame(int, int) (CGame.cpp:20)
==73932==  If you believe this happened as a result of a stack
==73932==  overflow in your program's main thread (unlikely but
==73932==  possible), you can try to increase the size of the
==73932==  main thread stack using the --main-stacksize= flag.
==73932==  The main thread stack size used in this run was 8388608.
==73932== 
==73932== HEAP SUMMARY:
==73932==     in use at exit: 127,490 bytes in 416 blocks
==73932==   total heap usage: 430 allocs, 14 frees, 209,424 bytes allocated
==73932== 
==73932== LEAK SUMMARY:
==73932==    definitely lost: 0 bytes in 0 blocks
==73932==    indirectly lost: 0 bytes in 0 blocks
==73932==      possibly lost: 0 bytes in 0 blocks
==73932==    still reachable: 127,490 bytes in 416 blocks
==73932==         suppressed: 0 bytes in 0 blocks
==73932== Rerun with --leak-check=full to see details of leaked memory
==73932== 
==73932== For lists of detected and suppressed errors, rerun with: -s
==73932== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
